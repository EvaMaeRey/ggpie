---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
options(tidyverse.quiet = TRUE)
```

# ggpie  ðŸ¦„ (is mostly mythical)

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

The goal of ggpie is to allow this ðŸ¦„ interface:

```{r, eval = F}
library(ggpie)

ggpie(diamonds) + 
  aes(fill = cut) + 
  geom_wedges()
```


Observations:  the `ggplot()` function start point has a particular set of defaults that might not be the best suited for final plot.

Assertion: other defaults can be bundled up and serve as grammatically-unproblematic alternative start points.


### Alternative without ggpie

We're looking at a geom_bar analogue, but it might be nice to do a geom_col too, where you have the counts yourself.  

```{r}
library(tidyverse)
diamonds %>%
ggplot() + 
  aes(x = 0, fill = cut) + 
  geom_bar() + 
  coord_polar(theta = "y") + 
  theme_void()
```

# Developing the new API.

```{r, pie_functions}
#' Title
#'
#' @return
#' @export
#'
#' @examples
defaults_pie <- function(){
  
  list(
    ggplot2::coord_polar(theta = "y"),
    ggplot2::theme_void(),
    ggplot2::aes(x = 0) # hacky; grammar problem
  )
  
}

#' Title
#'
#' @param data 
#'
#' @return
#' @export
#'
#' @examples
ggpie <- function(data){
  
  ggplot2::ggplot(data = data) + 
  defaults_pie()
  
}


# just aliasing to be nice to ourselves
# probably a better way 
# is doing more re-writing so that x is not a required aesthetic
#' Title
#'
#' @param ... 
#'
#' @return
#' @export
#'
#' @examples
geom_wedge <- function(...){
  
  ggplot2::geom_bar(...)
  
}


```


## Test it out


```{r}
ggpie(diamonds) + 
  aes(fill = cut) +
  geom_wedge() 

# a ggdonut() function could also be written
ggpie(diamonds) + 
  aes(fill = cut) +
  geom_wedge() +
  xlim(-2,1)
  
```


# Part II. Packaging and documentation  ðŸš§ âœ… 



## Phase 1. Minimal working package

### Created files for package archetecture with `devtools::create(".")` âœ… 

### Moved functions R folder? âœ…  

```{r}
knitr::knit_code$get() |> names()
```

Use new {readme2pkg} function to do this from readme... âœ… 

```{r, eval = F}
readme2pkg::chunk_to_r("pie_functions")
```



### Added roxygen skeleton? âœ… 

Use a roxygen skeleton for auto documentation and making sure proposed functions are *exported*.

### Managed dependencies ? âœ… 

Package dependencies managed, i.e. `depend::function()` in proposed functions and declared in the DESCRIPTION

```{r}
usethis::use_package("ggplot2")
```



### Chosen a license? âœ… 


```{r}
usethis::use_mit_license()
```

### Run `devtools::check()` and addressed errors? ðŸš§ 

```{r, results='hide', error=T}
devtools::check(pkg = ".")
```

### Build package ðŸš§ 

```{r}
devtools::build()
```

You need to do this before library(mynewpackage) will work.

### Make aspirational part of readme real. ðŸš§ 

At this point, you could change eval chunk options to TRUE. You can remove  the ðŸ¦„ emoji and perhaps replace it with construction site if you are still uncertain of the API, and want to highlight that it is subject to change. 

### Add lifecycle badge (experimental)âœ…  

```{r}
usethis::use_lifecycle_badge("experimental")
```


## Phase 2: Listen & iterate ðŸš§ 

Try to get feedback from experts on API, implementation, default decisions.  Is there already work that solves this problem? 


## Phase 3: Let thinggs settle

### Settled on examples.  Put them in the roxygen skeleton and readme. ðŸš§ 

### Written formal tests of functions? ðŸš§ 


That would look like this...

```{r test_calc_frequency_works, eval = F}
library(testthat)

test_that("calc frequency works", {
  expect_equal(calc_frequency("A", 0), 440)
  expect_equal(calc_frequency("A", -1), 220)
  
})
```


```{r, eval = F}
readme2pkg::chunk_to_tests_testthat("test_calc_frequency_works")
```


### Have you worked added a description and author information in the DESCRIPTION file? ðŸš§ 

### Addressed *all* notes, warnings and errors. ðŸš§ 

## Promote to wider audience...

### Package website built? ðŸš§ 

### Package website deployed? ðŸš§ 

## Phase 3: Harden/commit

### Submit to CRAN? Or don't.  ðŸš§ 

# Appendix: Reports, Environment

## Description file extract

```{r}

```

## Environment

Here I just want to print the packages and the versions

```{r}
all <- sessionInfo() |> print() |> capture.output()
all[11:17]
```

## `devtools::check()` report

```{r, error = T, results="hide", warning=F}
devtools::check(pkg = ".")
```




